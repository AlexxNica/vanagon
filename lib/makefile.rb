require 'vanagon/environment'

class Makefile
  # The Rule class defines a single Makefile rule.
  #
  # @see http://www.gnu.org/software/make/manual/make.html#Rule-Introduction
  class Rule
    # @!attribute [rw] target
    #   @return [String] The target generated by this rule.
    attr_accessor :target

    # @!attribute [rw] dependencies
    #   @return [Array<String>] A list of dependencies that this rule depends on.
    attr_accessor :dependencies

    # @!attribute [rw] environment
    #   @return [Array<String>] A list of environment variables that this rule
    #     will export
    attr_accessor :environment

    # @!attribute [rw] recipe
    #   @return [Array<String>] A list of commands to execute upon invocation of this rule.
    attr_accessor :recipe

    # Create a new Makefile rule. When a block is provided then it is called and passed the
    # newly created Rule object.
    #
    # @overload initialize(target, dependencies: [], recipe: [])
    #   @param target [String] target
    #   @param dependencies [Array<String>]]
    #   @param recipe [Array<String>]
    #
    # @overload initialize(target, dependencies: [], recipe: [], &block)
    #   @param target [String] target
    #   @param dependencies [Array<String>]]
    #   @param recipe [Array<String>]
    #   @yieldparam rule [Makefile::Rule]
    #
    #   @example Providing a block to #initialize
    #     newrule = Makefile::Rule.new("test", dependencies: ["all"]) do |rule|
    #       rule.recipe = [
    #         "make test",
    #         "make cpplint",
    #       ]
    #     end
    def initialize(target, dependencies: [], environment: Vanagon::Environment.new, recipe: [], &block)
      @target = target
      @dependencies = dependencies
      @environment = environment
      @recipe = recipe

      yield(self) if block
    end

    # @return [String, Nil] the name of all dependencies for a given rule,
    #   flattened and joined for a Makefule target
    def flatten_dependencies
      return nil if dependencies.empty?
      dependencies.flatten.join("\s")
    end

    # @return [String] the base Rule for a Makefile target, including
    #   all dependencies.
    def base_target
      ["#{target}:", dependencies].flatten.compact.join("\s")
    end

    # @return [String] the Makefile target's name, rendered in a format
    # suitable for using as a Graphite group -- any periods in the name of
    # the component being built will be removed.
    #   e.g. "ruby-2.1.9-unpack" will become "ruby-219.unpack"
    def tokenize_target_name
      target_name, _, rule = target.rpartition('-')
      [target_name.tr('.', ''), rule]
        .select { |s| !(s.nil? || s.empty?) }
        .join('.')
    end

    def profiled_target?
      !!(target =~ /-configure|-build|-install\Z/)
    end

    def tokenized_environment_variable
      "#{target}: export VANAGON_TARGET := #{tokenize_target_name}"
    end

    def environment_variables
      return [] unless profiled_target?

      environment.map { |k, v| "#{k} := #{v}" }.map do |env|
        "#{target}: export #{env}"
      end
    end

    # Format this rule as a Makefile rule.
    #
    # Recipes that have multiline statements will have tabs inserted after each
    # newline to ensure that the recipe is parsed as part of a single makefile rule.
    #
    # @return [String]
    def format # rubocop:disable Metrics/AbcSize
      # create a base target inside an Array, and construct the rest of
      # the rule around that.
      t = [base_target]

      # prepend an environment variable that can be used inside a
      # given Make rule/target. We have to do it this way instead of
      # appending it to #environment because for reasons that I cannot
      # work out, the "sane" way results in previous/incorrect names
      # being used and objects being recycled. My working theory is
      # a corner case between metaprogrammed methods in Component::Rules,
      # and Ruby's preference for pass-by-reference.
      # Ryan McKern 2017-02-02
      t.unshift tokenized_environment_variable if profiled_target?

      # prepend any environment variables to the existing target,
      # using the target prefix to identify them as such. they should
      # end up ahead of the dependencies and the build recipe.
      environment_variables.each do |env|
        t.unshift env
      end

      # finally, append the build recipe after the base target condition.
      # also, here's a fun edge case: if one were to call #squeeze on
      # the iterator 'line', basically all of the phony make tasks that
      # `touch` a file just disapear. Fragility ++.
      # - Ryan McKern 2017-02-02
      t.push recipe.compact.map { |line| "\t" + line.gsub("\n", "\n\t") + "\n" }.join
      t.join("\n")
    end

    alias to_s format
  end
end
